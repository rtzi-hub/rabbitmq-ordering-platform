# values/dev/postgresql.yaml
auth:
  enablePostgresUser: true

  username: "postgresdb"
  database: "postgresdb"

  postgresPassword: ""
  password: ""
  existingSecret: "postgresql-credentials-database"

primary:
  persistence:
    enabled: true
    type: pvc
    size: 2Gi
    storageClassName: local-path

  resources:
    requests:
      cpu: 50m
      memory: 256Mi
    limits:
      cpu: 200m
      memory: 512Mi

  initdb:
    scripts:
      01_ordering_schema.sql: |-
        -- 1. Shows
        CREATE TABLE IF NOT EXISTS shows (
            id         SERIAL PRIMARY KEY,
            name       TEXT        NOT NULL,
            venue      TEXT        NOT NULL,
            starts_at  TIMESTAMPTZ NOT NULL,
            capacity   INTEGER     NOT NULL CHECK (capacity > 0),
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- 2. Orders
        CREATE TABLE IF NOT EXISTS orders (
            id         SERIAL PRIMARY KEY,
            user_id    TEXT        NOT NULL,
            show_id    INTEGER     NOT NULL REFERENCES shows(id) ON DELETE RESTRICT,
            quantity   INTEGER     NOT NULL CHECK (quantity > 0),
            status     TEXT        NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        CREATE INDEX IF NOT EXISTS idx_orders_show_id ON orders(show_id);
        CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);

        -- 3. Payments
        CREATE TABLE IF NOT EXISTS payments (
            id         SERIAL PRIMARY KEY,
            order_id   INTEGER     NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
            user_id    TEXT        NOT NULL,
            amount     INTEGER     NOT NULL,
            status     TEXT        NOT NULL,
            message_id TEXT        NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        -- Keep the unique index (fast + good), and also add a named constraint for clarity
        -- (Some teams prefer constraints for schema semantics)
        CREATE UNIQUE INDEX IF NOT EXISTS ux_payments_message_id ON payments(message_id);
        CREATE INDEX IF NOT EXISTS idx_payments_order_id ON payments(order_id);
        CREATE INDEX IF NOT EXISTS idx_payments_user_id ON payments(user_id);

        -- ADD CONSTRAINT (idempotent):
        -- Use a DO block so it won't fail if the constraint already exists.
        DO $$
        BEGIN
          IF NOT EXISTS (
            SELECT 1
            FROM   pg_constraint
            WHERE  conname = 'payments_message_id_unique'
          ) THEN
            -- Reuse the unique index we created above
            ALTER TABLE payments
              ADD CONSTRAINT payments_message_id_unique
              UNIQUE USING INDEX ux_payments_message_id;
          END IF;
        END$$;

        -- 4. Inventory
        CREATE TABLE IF NOT EXISTS inventory_reservations (
            id         SERIAL PRIMARY KEY,
            show_id    INTEGER     NOT NULL REFERENCES shows(id) ON DELETE CASCADE,
            order_id   INTEGER     REFERENCES orders(id) ON DELETE SET NULL,
            quantity   INTEGER     NOT NULL CHECK (quantity > 0),
            status     TEXT        NOT NULL,
            expires_at TIMESTAMPTZ NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        CREATE INDEX IF NOT EXISTS idx_inventory_reservations_show_id
          ON inventory_reservations(show_id);
        CREATE INDEX IF NOT EXISTS idx_inventory_reservations_expires_at
          ON inventory_reservations(expires_at);

        -- 5. Seed shows
        INSERT INTO shows (name, venue, starts_at, capacity)
        VALUES
          ('Rock Festival 2025',      'Main Arena', NOW() + INTERVAL '7 days',  5000),
          ('Tech Conference Keynote', 'Hall A',     NOW() + INTERVAL '14 days',  800),
          ('Standup Night',           'Small Club', NOW() + INTERVAL '3 days',   120)
        ON CONFLICT DO NOTHING;
